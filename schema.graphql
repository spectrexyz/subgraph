enum SpectreState {
  Null
  Locked
  Unlocked
}

enum IssuanceState {
  Null
  Opened
  Closed
}

enum SaleState {
  Null
  Pending
  Opened
  Closed
}

# vault-related entities

type NFT @entity {
  id: ID! # address#id
  collection: Bytes!
  tokenId: BigInt!
}

type Spectre @entity {
  id: ID! # ERC1155 tokenType
  NFT: NFT!
  sERC20: sERC20!
  state: SpectreState!
  vault: Bytes!
  broker: Bytes!
  issuance: Issuance
  sale: Sale
}

# sERC20-related entities

type sERC20 @entity {
  id: ID! # ERC20 address
  name: String!
  symbol: String!
  cap: BigInt!
  spectre: Spectre!
  pool: Pool
}

type Sale @entity {
  id: ID! # ERC20 address
  spectre: Spectre!
  state: SaleState!
  guardian: Bytes!
  reserve: BigInt!
  multiplier: BigInt!
  opening: BigInt!
  stock: BigInt!
  nbOfProposals: BigInt!
  flash: Boolean
  escape: Boolean
}

type Issuance @entity {
  id: ID! # ERC20 address
  spectre: Spectre!
  state: IssuanceState!
  guardian: Bytes!
  pool: Bytes!
  poolId: Bytes!
  reserve: BigInt!
  allocation: BigInt!
  fee: BigInt!
  nbOfProposals: BigInt!
  flash: Boolean
}

# pool-related entities

type Pool @entity {
  id: ID! # poolId
  address: Bytes!
  sERC20: sERC20!
  sERC20IsToken0: Boolean!
  states: [PoolState!]! @derivedFrom(field: "pool")
  swaps: [Swap!]! @derivedFrom(field: "pool")
  joins: [Join!]! @derivedFrom(field: "pool")
}

type Swap @entity {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  amounts: [BigInt!]! # sERC20 is always first, ETH second
}

type Join @entity {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  amounts: [BigInt!]! # sERC20 is always first, ETH second
}

# event PoolBalanceChanged(
#         bytes32 indexed poolId,
#         address indexed liquidityProvider,
#         IERC20[] tokens,
#         int256[] deltas,
#         uint256[] protocolFeeAmounts
#     );

type PoolState @entity {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  balances: [BigInt!]! # sERC20 is always first, ETH second
  weights: [BigInt!]! # sERC20 is always first, ETH second
  price: BigDecimal!
}
